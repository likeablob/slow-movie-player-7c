#include <Arduino.h>
#include <esp32/ulp.h>

// Third-party libs
#include <ulptool.h>

// Special header generated by ulptool
#include "ulp_main.h"

// Local headers
#include "SMP7C.h"
#include "pm.h"
#include "stash.h"
#include "ulp_common.h"

#define ULP_WAKEUP_PERIOD_US (1000 * 1000) // 1 sec
#define DEBUG_SERIAL_BAUD 115200
#define STASH_SAVE_PERIOD                                                      \
    10 // Save status to non-volatile storage for every N wake ups

extern const uint8_t ulp_main_bin_start[] asm("_binary_ulp_main_bin_start");
extern const uint8_t ulp_main_bin_end[] asm("_binary_ulp_main_bin_end");

// RTC variables
RTC_DATA_ATTR uint32_t RTC_SMP7C_frameInd = 0;

static void init_run_ulp(uint32_t usec) {
    ulp_set_wakeup_period(0, usec);
    esp_deep_sleep_disable_rom_logging(); // Suppress boot messages

    esp_err_t err = ulptool_load_binary(
        0, ulp_main_bin_start,
        (ulp_main_bin_end - ulp_main_bin_start) / sizeof(uint32_t));
    err = ulp_run((&ulp_entry - RTC_SLOW_MEM) / sizeof(uint32_t));

    if(err) {
        Serial.println("Error Starting ULP Coprocessor");
    }

    esp_sleep_enable_ulp_wakeup();
}

void start_deep_sleep() {
    // Save variables into RTC SLOW MEM
    RTC_SMP7C_frameInd = SMP7C.frameInd;

    PM::prepareRtcPinsForDeepSleep();
    esp_deep_sleep_start();
}

void reboot_by_deep_sleep() {
    PM::disableBusPower();
    init_run_ulp(ULP_WAKEUP_PERIOD_US);
    ulp__counterPeriodicTask = (ulp__counterPeriodicTask & 0xFFFF0000) |
                               ((COUNTER_PERIODIC_TASK - 3) & UINT16_MAX);
    start_deep_sleep();
}

void setup() {
    Serial.begin(DEBUG_SERIAL_BAUD);
    Serial.printf("started: %lu\n", millis());

    esp_sleep_wakeup_cause_t cause = esp_sleep_get_wakeup_cause();
    if(cause != ESP_SLEEP_WAKEUP_ULP) {
        Serial.println("Not ULP wakeup");

        // Restore variables from non-volatile memory
        if(Stash::restore(SMP7C.frameInd)) {
            Serial.printf("Restored from Stash: frameInd: %u\n",
                          SMP7C.frameInd);
        } else {
            Serial.printf("Failed to load from Stash\n");
        }
    } else {
        Serial.printf("ULP wakeup\n");
        PM::resetRtcPins();

        // Restore variables from RTC SLOW MEM
        SMP7C.frameInd = RTC_SMP7C_frameInd;
        Serial.printf("Restored: frameInd: %u\n", SMP7C.frameInd);

        // Save variables to non-volatile memory
        if(!(SMP7C.frameInd % STASH_SAVE_PERIOD)) {
            Serial.println("Saving to Stash.");
            if(!Stash::save(SMP7C.frameInd)) {
                Serial.printf("Failed to save to Stash\n");
            }
        }
    }

    // Turn on bus power for microSD and EPD.
    PM::enableBusPower();

    // Init (Init FS, open files, etc.)
    if(!SMP7C.begin(DEBUG_SERIAL_BAUD)) {
        // Restart immediately if fails
        Serial.println("SMP7C.begin() failed. Rebooting.");
        reboot_by_deep_sleep();
        return;
    }

    // Render (Load a frame, send it to EPD.)
    if(!SMP7C.renderFrame()) {
        Serial.println("SMP7C.renderFrame() failed. Rebooting.");
        reboot_by_deep_sleep();
        return;
    }

    // Prepare for deep sleep.
    init_run_ulp(ULP_WAKEUP_PERIOD_US);
    PM::setWaitBusyRequest(ulp_status); // EPD_BUSY will be handled by ULP.

    Serial.printf("Elapsed: %lu\n", millis());
    start_deep_sleep();
}

void loop() {
    // NOP
}
